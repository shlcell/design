# 设计模式gof

- **创建型模式**：单例模式，**工厂模式**，抽象工厂模式，建造者模式，原型模式
- **结构型模式**:   适配器模式，桥接模式，**装饰模式**，组合模式，**外观模式**，**亨元模式**，代理模式
- **行为型模式：**模板方法模式，命令模式，迭代器模式，**观察者模式**，中介者模式，备忘录模式，解释器模式，**状态模式**，**策略模式**，**职责链模式**，访问者模式

## 1. OOP七大原则

1. 开闭原则ocp：扩展开放，对修改关闭
2. 里氏替换原则：继承必须确保超类所拥有的性质在子类中仍然成立
3. 依赖倒置原则：要面向接口编程，不要面向现实编程
4. 单一职责原则：控制类的粒度大小，将对象解耦，提高其内聚性。
5. 接口隔离原则：要为各个类建立他们需要的专用接口
6. 迪米特法则：只与你的直接朋友交谈，不跟陌生人说话。
7. 合成复用原则：尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现

## 2. UML类图

- 定义：用于描述系统中的类（对象）本身的组成和类（对象）之间的各种静态关系。

- 类之间的关系：依赖，泛化（继承），实现，关联，聚合，组合

- UML图分类：
  - 用例图
  - 静态结构图：类图，对象图，包图，组件图，部署图
  - 动态行为图：交互图，（时序图与协作图），状态图，活动图

## 3. 单例模式

## 4. 工厂模式

1. 简单工厂模式：用来生产同一等级结构中的任意产品。（不支持拓展增加产品）改动需要修改原代码
2. 工厂方法模式：用来生产同一等级结构中的固定产品。（支持拓展增加产品）
3. 抽象工厂模式 ：用来生产不同产品族的全部产品。（不支持拓展增加产品；支持增加产品族）

## 5. 建造者模式

### 5.1 定义：

- 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。
- 工厂类模式是提供的是创建单个类的产品
- 而建造者模式则是将各种产品集中起来进行管理，用来具有不同的属性的产品


### 5.2 应用场景

1. 产品对象具备共性

2. 隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同的产品

3. 适用于一个具有较多零件（属性）的产品（对象）的创建过程。

- 与工厂模式的区别是：建造者模式更加关注与零件装配的顺序。
- JAVA 中的 StringBuilder就是建造者模式创建的，他把一个单个字符的char数组组合起来
- Spring不是建造者模式，它提供的操作应该是对于字符串本身的一些操作，而不是创建或改变一个 字符串。

## 6. 原型模式

```
* 1.实现一个接口:Cloneable
* 2.重写一个方法:clone()
```

### 1.什么是原型模式 
- 原型设计模式简单来说就是克隆 
- 原型表明了有一个样板实例，这个原型是可定制的。原型模式多用于创建复杂的或者构造耗时的实 例，因为这种情况下，复制一个已经存在的实例可使程序运行更高效。 

### 2.原型模式的应用场景 
1. 类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等。这时我们就可以通过原型拷贝 避免这些消耗。 
2. 通过new产生的一个对象需要非常繁琐的数据准备或者权限，这时可以使用原型模式。 
3. 一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模 式拷贝多个对象供调用者使用，即保护性拷贝。 我们Spring框架中的多例就是使用原型。 

### 3.原型模式的使用方式 
1. 实现Cloneable接口。在java语言有一个Cloneable接口，它的作用只有一个，就是在运行时通知 虚拟机可以安全地在实现了此接口的类上使用clone方法。在java虚拟机中，只有实现了这个接口 的类才可以被拷贝，否则在运行时会抛出CloneNotSupportedException异常。 
2. 重写Object类中的clone方法。Java中，所有类的父类都是Object类，Object类中有一个clone方 法，作用是返回对象的一个拷贝，但是其作用域protected类型的，一般的类无法调用，因此 Prototype类需要将clone方法的作用域修改为public类型。

- #### 原型模式分为浅复制和深复制 

1. （浅复制）只是拷贝了基本类型的数据，而引用类型数据，只是拷贝了一份引用地址。
2. （深复制）在计算机中开辟了一块新的内存地址用于存放复制的对象。

## 7. 适配器模式

联想： 电脑--转接头--网线

## 8. 桥接模式

## 9. 代理模式

- 静态代理
- 动态代理

## 10. 观察者模式(发布-订阅模式)

### 1.什么是观察者模式 
- 先讲什么是行为性模型，行为型模式关注的是系统中对象之间的相互交互，解决系统在运行时对象 之间的相互通信和协作，进一步明确对象的职责。 
- 观察者模式，是一种行为性模型，又叫**发布-订阅模式**，他定义对象之间一种一对多的依赖关系， 使得当一个对象改变状态，则所有依赖于它的对象都会得到通知并自动更新。 

### 2.模式的职责 
- 观察者模式主要用于1对N的通知。当一个对象的状态变化时，他需要及时告知一系列对象，令他 们做出相应。 
- 实现有两种方式： 
  1. 推：每次都会把通知以广播的方式发送给所有观察者，所有的观察者只能被动接收。
  2. 拉：观察者只要知道有情况即可，至于什么时候获取内容，获取什么内容，都可以自主决定。 

### 3.观察者模式应用场景 
  1.关联行为场景，需要注意的是，关联行为是可拆分的，而不是“组合”关系。事件多级触发场景。 
  2.跨系统的消息交换场景，如消息队列、事件总线的处理机制。

## 11. 模板模式

### 1.什么是模板方法 

模板方法模式：定义一个操作中的算法骨架（父类），而将一些步骤延迟到子类中。 模板方法使 得子类可以不改变一个算法的结构来重定义该算法的 

### 2.什么时候使用模板方法 

实现一些操作时，整体步骤很固定，但是呢。就是其中一小部分需要改变，这时候可以使用模板方 法模式，将容易变的部分抽象出来，供子类实现。

###  3.实际开发中应用场景

其实很多框架中都有用到了模板方法模式 例如：数据库访问的封装、Junit单元测试、servlet中关于doGet/doPost方法的调用等等 

### 4.现实生活中的模板方法 

例如： 1. 去餐厅吃饭，餐厅给我们提供了一个模板就是：看菜单，点菜，吃饭，付款，走人 （这里 “点菜和 付款” 是不确定的由子类来完成的，其他的则是一个模板。）

## 12. 外观模式

### 1.什么是外观模式 

- 外观模式：也叫**门面模式**，隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接 口。 
- 它向现有的系统添加一个接口，用这一个接口来隐藏实际的系统的复杂性。 
- 使用外观模式，他外部看起来就是一个接口，其实他的内部有很多复杂的接口已经被实现

## 13. 策略模式

### 1.什么是策略模式 

 - 定义了一系列的算法 或 逻辑 或 相同意义的操作，并将每一个算法、逻辑、操作封装起来，而且 使它们还可以相互替换。（其实策略模式Java中用的非常非常广泛） 
 - 我觉得主要是为了 简化 if...else 所带来的复杂和难以维护。 

### 2.策略模式应用场景 

 - **策略模式的用意是针对一组算法或逻辑**，将每一个算法或逻辑封装到具有共同接口的独立的类中， 从而使得它们之间可以相互替换。 
 1. 例如：我要做一个不同会员打折力度不同的三种策略，初级会员，中级会员，高级会员（三种不同 的计算）。 
 2. 例如：我要一个支付模块，我要有微信支付、支付宝支付、银联支付等 

### 3.策略模式的优点和缺点 

- 优点： 1、算法可以自由切换。 2、避免使用多重条件判断。 3、扩展性非常良好。 
- 缺点： 1、策略类会增多。 2、所有策略类都需要对外暴露。
